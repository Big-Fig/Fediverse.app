// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'account_repository_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AccountRepositoryFiltersTearOff {
  const _$AccountRepositoryFiltersTearOff();

  _AccountRepositoryFilters call(
      {required IConversationChat? onlyInConversation,
      required IUnifediChat? onlyInChat,
      required IStatus? onlyInStatusRebloggedBy,
      required IStatus? onlyInStatusFavouritedBy,
      required IAccount? onlyInAccountFollowers,
      required IAccount? onlyInAccountFollowing,
      required String? searchQuery}) {
    return _AccountRepositoryFilters(
      onlyInConversation: onlyInConversation,
      onlyInChat: onlyInChat,
      onlyInStatusRebloggedBy: onlyInStatusRebloggedBy,
      onlyInStatusFavouritedBy: onlyInStatusFavouritedBy,
      onlyInAccountFollowers: onlyInAccountFollowers,
      onlyInAccountFollowing: onlyInAccountFollowing,
      searchQuery: searchQuery,
    );
  }
}

/// @nodoc
const $AccountRepositoryFilters = _$AccountRepositoryFiltersTearOff();

/// @nodoc
mixin _$AccountRepositoryFilters {
  IConversationChat? get onlyInConversation =>
      throw _privateConstructorUsedError;
  IUnifediChat? get onlyInChat => throw _privateConstructorUsedError;
  IStatus? get onlyInStatusRebloggedBy => throw _privateConstructorUsedError;
  IStatus? get onlyInStatusFavouritedBy => throw _privateConstructorUsedError;
  IAccount? get onlyInAccountFollowers => throw _privateConstructorUsedError;
  IAccount? get onlyInAccountFollowing => throw _privateConstructorUsedError;
  String? get searchQuery => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AccountRepositoryFiltersCopyWith<AccountRepositoryFilters> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountRepositoryFiltersCopyWith<$Res> {
  factory $AccountRepositoryFiltersCopyWith(AccountRepositoryFilters value,
          $Res Function(AccountRepositoryFilters) then) =
      _$AccountRepositoryFiltersCopyWithImpl<$Res>;
  $Res call(
      {IConversationChat? onlyInConversation,
      IUnifediChat? onlyInChat,
      IStatus? onlyInStatusRebloggedBy,
      IStatus? onlyInStatusFavouritedBy,
      IAccount? onlyInAccountFollowers,
      IAccount? onlyInAccountFollowing,
      String? searchQuery});
}

/// @nodoc
class _$AccountRepositoryFiltersCopyWithImpl<$Res>
    implements $AccountRepositoryFiltersCopyWith<$Res> {
  _$AccountRepositoryFiltersCopyWithImpl(this._value, this._then);

  final AccountRepositoryFilters _value;
  // ignore: unused_field
  final $Res Function(AccountRepositoryFilters) _then;

  @override
  $Res call({
    Object? onlyInConversation = freezed,
    Object? onlyInChat = freezed,
    Object? onlyInStatusRebloggedBy = freezed,
    Object? onlyInStatusFavouritedBy = freezed,
    Object? onlyInAccountFollowers = freezed,
    Object? onlyInAccountFollowing = freezed,
    Object? searchQuery = freezed,
  }) {
    return _then(_value.copyWith(
      onlyInConversation: onlyInConversation == freezed
          ? _value.onlyInConversation
          : onlyInConversation // ignore: cast_nullable_to_non_nullable
              as IConversationChat?,
      onlyInChat: onlyInChat == freezed
          ? _value.onlyInChat
          : onlyInChat // ignore: cast_nullable_to_non_nullable
              as IUnifediChat?,
      onlyInStatusRebloggedBy: onlyInStatusRebloggedBy == freezed
          ? _value.onlyInStatusRebloggedBy
          : onlyInStatusRebloggedBy // ignore: cast_nullable_to_non_nullable
              as IStatus?,
      onlyInStatusFavouritedBy: onlyInStatusFavouritedBy == freezed
          ? _value.onlyInStatusFavouritedBy
          : onlyInStatusFavouritedBy // ignore: cast_nullable_to_non_nullable
              as IStatus?,
      onlyInAccountFollowers: onlyInAccountFollowers == freezed
          ? _value.onlyInAccountFollowers
          : onlyInAccountFollowers // ignore: cast_nullable_to_non_nullable
              as IAccount?,
      onlyInAccountFollowing: onlyInAccountFollowing == freezed
          ? _value.onlyInAccountFollowing
          : onlyInAccountFollowing // ignore: cast_nullable_to_non_nullable
              as IAccount?,
      searchQuery: searchQuery == freezed
          ? _value.searchQuery
          : searchQuery // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$AccountRepositoryFiltersCopyWith<$Res>
    implements $AccountRepositoryFiltersCopyWith<$Res> {
  factory _$AccountRepositoryFiltersCopyWith(_AccountRepositoryFilters value,
          $Res Function(_AccountRepositoryFilters) then) =
      __$AccountRepositoryFiltersCopyWithImpl<$Res>;
  @override
  $Res call(
      {IConversationChat? onlyInConversation,
      IUnifediChat? onlyInChat,
      IStatus? onlyInStatusRebloggedBy,
      IStatus? onlyInStatusFavouritedBy,
      IAccount? onlyInAccountFollowers,
      IAccount? onlyInAccountFollowing,
      String? searchQuery});
}

/// @nodoc
class __$AccountRepositoryFiltersCopyWithImpl<$Res>
    extends _$AccountRepositoryFiltersCopyWithImpl<$Res>
    implements _$AccountRepositoryFiltersCopyWith<$Res> {
  __$AccountRepositoryFiltersCopyWithImpl(_AccountRepositoryFilters _value,
      $Res Function(_AccountRepositoryFilters) _then)
      : super(_value, (v) => _then(v as _AccountRepositoryFilters));

  @override
  _AccountRepositoryFilters get _value =>
      super._value as _AccountRepositoryFilters;

  @override
  $Res call({
    Object? onlyInConversation = freezed,
    Object? onlyInChat = freezed,
    Object? onlyInStatusRebloggedBy = freezed,
    Object? onlyInStatusFavouritedBy = freezed,
    Object? onlyInAccountFollowers = freezed,
    Object? onlyInAccountFollowing = freezed,
    Object? searchQuery = freezed,
  }) {
    return _then(_AccountRepositoryFilters(
      onlyInConversation: onlyInConversation == freezed
          ? _value.onlyInConversation
          : onlyInConversation // ignore: cast_nullable_to_non_nullable
              as IConversationChat?,
      onlyInChat: onlyInChat == freezed
          ? _value.onlyInChat
          : onlyInChat // ignore: cast_nullable_to_non_nullable
              as IUnifediChat?,
      onlyInStatusRebloggedBy: onlyInStatusRebloggedBy == freezed
          ? _value.onlyInStatusRebloggedBy
          : onlyInStatusRebloggedBy // ignore: cast_nullable_to_non_nullable
              as IStatus?,
      onlyInStatusFavouritedBy: onlyInStatusFavouritedBy == freezed
          ? _value.onlyInStatusFavouritedBy
          : onlyInStatusFavouritedBy // ignore: cast_nullable_to_non_nullable
              as IStatus?,
      onlyInAccountFollowers: onlyInAccountFollowers == freezed
          ? _value.onlyInAccountFollowers
          : onlyInAccountFollowers // ignore: cast_nullable_to_non_nullable
              as IAccount?,
      onlyInAccountFollowing: onlyInAccountFollowing == freezed
          ? _value.onlyInAccountFollowing
          : onlyInAccountFollowing // ignore: cast_nullable_to_non_nullable
              as IAccount?,
      searchQuery: searchQuery == freezed
          ? _value.searchQuery
          : searchQuery // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_AccountRepositoryFilters extends _AccountRepositoryFilters {
  const _$_AccountRepositoryFilters(
      {required this.onlyInConversation,
      required this.onlyInChat,
      required this.onlyInStatusRebloggedBy,
      required this.onlyInStatusFavouritedBy,
      required this.onlyInAccountFollowers,
      required this.onlyInAccountFollowing,
      required this.searchQuery})
      : super._();

  @override
  final IConversationChat? onlyInConversation;
  @override
  final IUnifediChat? onlyInChat;
  @override
  final IStatus? onlyInStatusRebloggedBy;
  @override
  final IStatus? onlyInStatusFavouritedBy;
  @override
  final IAccount? onlyInAccountFollowers;
  @override
  final IAccount? onlyInAccountFollowing;
  @override
  final String? searchQuery;

  @override
  String toString() {
    return 'AccountRepositoryFilters(onlyInConversation: $onlyInConversation, onlyInChat: $onlyInChat, onlyInStatusRebloggedBy: $onlyInStatusRebloggedBy, onlyInStatusFavouritedBy: $onlyInStatusFavouritedBy, onlyInAccountFollowers: $onlyInAccountFollowers, onlyInAccountFollowing: $onlyInAccountFollowing, searchQuery: $searchQuery)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AccountRepositoryFilters &&
            (identical(other.onlyInConversation, onlyInConversation) ||
                const DeepCollectionEquality()
                    .equals(other.onlyInConversation, onlyInConversation)) &&
            (identical(other.onlyInChat, onlyInChat) ||
                const DeepCollectionEquality()
                    .equals(other.onlyInChat, onlyInChat)) &&
            (identical(
                    other.onlyInStatusRebloggedBy, onlyInStatusRebloggedBy) ||
                const DeepCollectionEquality().equals(
                    other.onlyInStatusRebloggedBy, onlyInStatusRebloggedBy)) &&
            (identical(
                    other.onlyInStatusFavouritedBy, onlyInStatusFavouritedBy) ||
                const DeepCollectionEquality().equals(
                    other.onlyInStatusFavouritedBy,
                    onlyInStatusFavouritedBy)) &&
            (identical(other.onlyInAccountFollowers, onlyInAccountFollowers) ||
                const DeepCollectionEquality().equals(
                    other.onlyInAccountFollowers, onlyInAccountFollowers)) &&
            (identical(other.onlyInAccountFollowing, onlyInAccountFollowing) ||
                const DeepCollectionEquality().equals(
                    other.onlyInAccountFollowing, onlyInAccountFollowing)) &&
            (identical(other.searchQuery, searchQuery) ||
                const DeepCollectionEquality()
                    .equals(other.searchQuery, searchQuery)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(onlyInConversation) ^
      const DeepCollectionEquality().hash(onlyInChat) ^
      const DeepCollectionEquality().hash(onlyInStatusRebloggedBy) ^
      const DeepCollectionEquality().hash(onlyInStatusFavouritedBy) ^
      const DeepCollectionEquality().hash(onlyInAccountFollowers) ^
      const DeepCollectionEquality().hash(onlyInAccountFollowing) ^
      const DeepCollectionEquality().hash(searchQuery);

  @JsonKey(ignore: true)
  @override
  _$AccountRepositoryFiltersCopyWith<_AccountRepositoryFilters> get copyWith =>
      __$AccountRepositoryFiltersCopyWithImpl<_AccountRepositoryFilters>(
          this, _$identity);
}

abstract class _AccountRepositoryFilters extends AccountRepositoryFilters {
  const factory _AccountRepositoryFilters(
      {required IConversationChat? onlyInConversation,
      required IUnifediChat? onlyInChat,
      required IStatus? onlyInStatusRebloggedBy,
      required IStatus? onlyInStatusFavouritedBy,
      required IAccount? onlyInAccountFollowers,
      required IAccount? onlyInAccountFollowing,
      required String? searchQuery}) = _$_AccountRepositoryFilters;
  const _AccountRepositoryFilters._() : super._();

  @override
  IConversationChat? get onlyInConversation =>
      throw _privateConstructorUsedError;
  @override
  IUnifediChat? get onlyInChat => throw _privateConstructorUsedError;
  @override
  IStatus? get onlyInStatusRebloggedBy => throw _privateConstructorUsedError;
  @override
  IStatus? get onlyInStatusFavouritedBy => throw _privateConstructorUsedError;
  @override
  IAccount? get onlyInAccountFollowers => throw _privateConstructorUsedError;
  @override
  IAccount? get onlyInAccountFollowing => throw _privateConstructorUsedError;
  @override
  String? get searchQuery => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$AccountRepositoryFiltersCopyWith<_AccountRepositoryFilters> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$AccountRepositoryOrderingTermDataTearOff {
  const _$AccountRepositoryOrderingTermDataTearOff();

  _AccountRepositoryOrderingTermData call(
      {required AccountOrderType orderType,
      required moor.OrderingMode orderingMode}) {
    return _AccountRepositoryOrderingTermData(
      orderType: orderType,
      orderingMode: orderingMode,
    );
  }
}

/// @nodoc
const $AccountRepositoryOrderingTermData =
    _$AccountRepositoryOrderingTermDataTearOff();

/// @nodoc
mixin _$AccountRepositoryOrderingTermData {
  AccountOrderType get orderType => throw _privateConstructorUsedError;
  moor.OrderingMode get orderingMode => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AccountRepositoryOrderingTermDataCopyWith<AccountRepositoryOrderingTermData>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AccountRepositoryOrderingTermDataCopyWith<$Res> {
  factory $AccountRepositoryOrderingTermDataCopyWith(
          AccountRepositoryOrderingTermData value,
          $Res Function(AccountRepositoryOrderingTermData) then) =
      _$AccountRepositoryOrderingTermDataCopyWithImpl<$Res>;
  $Res call({AccountOrderType orderType, moor.OrderingMode orderingMode});
}

/// @nodoc
class _$AccountRepositoryOrderingTermDataCopyWithImpl<$Res>
    implements $AccountRepositoryOrderingTermDataCopyWith<$Res> {
  _$AccountRepositoryOrderingTermDataCopyWithImpl(this._value, this._then);

  final AccountRepositoryOrderingTermData _value;
  // ignore: unused_field
  final $Res Function(AccountRepositoryOrderingTermData) _then;

  @override
  $Res call({
    Object? orderType = freezed,
    Object? orderingMode = freezed,
  }) {
    return _then(_value.copyWith(
      orderType: orderType == freezed
          ? _value.orderType
          : orderType // ignore: cast_nullable_to_non_nullable
              as AccountOrderType,
      orderingMode: orderingMode == freezed
          ? _value.orderingMode
          : orderingMode // ignore: cast_nullable_to_non_nullable
              as moor.OrderingMode,
    ));
  }
}

/// @nodoc
abstract class _$AccountRepositoryOrderingTermDataCopyWith<$Res>
    implements $AccountRepositoryOrderingTermDataCopyWith<$Res> {
  factory _$AccountRepositoryOrderingTermDataCopyWith(
          _AccountRepositoryOrderingTermData value,
          $Res Function(_AccountRepositoryOrderingTermData) then) =
      __$AccountRepositoryOrderingTermDataCopyWithImpl<$Res>;
  @override
  $Res call({AccountOrderType orderType, moor.OrderingMode orderingMode});
}

/// @nodoc
class __$AccountRepositoryOrderingTermDataCopyWithImpl<$Res>
    extends _$AccountRepositoryOrderingTermDataCopyWithImpl<$Res>
    implements _$AccountRepositoryOrderingTermDataCopyWith<$Res> {
  __$AccountRepositoryOrderingTermDataCopyWithImpl(
      _AccountRepositoryOrderingTermData _value,
      $Res Function(_AccountRepositoryOrderingTermData) _then)
      : super(_value, (v) => _then(v as _AccountRepositoryOrderingTermData));

  @override
  _AccountRepositoryOrderingTermData get _value =>
      super._value as _AccountRepositoryOrderingTermData;

  @override
  $Res call({
    Object? orderType = freezed,
    Object? orderingMode = freezed,
  }) {
    return _then(_AccountRepositoryOrderingTermData(
      orderType: orderType == freezed
          ? _value.orderType
          : orderType // ignore: cast_nullable_to_non_nullable
              as AccountOrderType,
      orderingMode: orderingMode == freezed
          ? _value.orderingMode
          : orderingMode // ignore: cast_nullable_to_non_nullable
              as moor.OrderingMode,
    ));
  }
}

/// @nodoc

class _$_AccountRepositoryOrderingTermData
    extends _AccountRepositoryOrderingTermData {
  const _$_AccountRepositoryOrderingTermData(
      {required this.orderType, required this.orderingMode})
      : super._();

  @override
  final AccountOrderType orderType;
  @override
  final moor.OrderingMode orderingMode;

  @override
  String toString() {
    return 'AccountRepositoryOrderingTermData(orderType: $orderType, orderingMode: $orderingMode)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _AccountRepositoryOrderingTermData &&
            (identical(other.orderType, orderType) ||
                const DeepCollectionEquality()
                    .equals(other.orderType, orderType)) &&
            (identical(other.orderingMode, orderingMode) ||
                const DeepCollectionEquality()
                    .equals(other.orderingMode, orderingMode)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(orderType) ^
      const DeepCollectionEquality().hash(orderingMode);

  @JsonKey(ignore: true)
  @override
  _$AccountRepositoryOrderingTermDataCopyWith<
          _AccountRepositoryOrderingTermData>
      get copyWith => __$AccountRepositoryOrderingTermDataCopyWithImpl<
          _AccountRepositoryOrderingTermData>(this, _$identity);
}

abstract class _AccountRepositoryOrderingTermData
    extends AccountRepositoryOrderingTermData {
  const factory _AccountRepositoryOrderingTermData(
          {required AccountOrderType orderType,
          required moor.OrderingMode orderingMode}) =
      _$_AccountRepositoryOrderingTermData;
  const _AccountRepositoryOrderingTermData._() : super._();

  @override
  AccountOrderType get orderType => throw _privateConstructorUsedError;
  @override
  moor.OrderingMode get orderingMode => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$AccountRepositoryOrderingTermDataCopyWith<
          _AccountRepositoryOrderingTermData>
      get copyWith => throw _privateConstructorUsedError;
}
