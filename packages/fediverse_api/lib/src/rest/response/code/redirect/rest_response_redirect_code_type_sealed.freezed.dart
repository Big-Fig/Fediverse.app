// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'rest_response_redirect_code_type_sealed.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$RestResponseRedirectCodeTypeTearOff {
  const _$RestResponseRedirectCodeTypeTearOff();

  _MultipleChoice multipleChoice(
      {int intValue = RestResponseRedirectCodeType.multipleChoiceIntValue}) {
    return _MultipleChoice(
      intValue: intValue,
    );
  }

  _Moved moved({int intValue = RestResponseRedirectCodeType.movedIntValue}) {
    return _Moved(
      intValue: intValue,
    );
  }

  _Found found({int intValue = RestResponseRedirectCodeType.foundIntValue}) {
    return _Found(
      intValue: intValue,
    );
  }

  _SeeOther seeOther(
      {int intValue = RestResponseRedirectCodeType.seeOtherIntValue}) {
    return _SeeOther(
      intValue: intValue,
    );
  }

  _NotModified notModified(
      {int intValue = RestResponseRedirectCodeType.notModifiedIntValue}) {
    return _NotModified(
      intValue: intValue,
    );
  }

  _UseProxy useProxy(
      {int intValue = RestResponseRedirectCodeType.useProxyIntValue}) {
    return _UseProxy(
      intValue: intValue,
    );
  }

  _Unused unused({int intValue = RestResponseRedirectCodeType.unusedIntValue}) {
    return _Unused(
      intValue: intValue,
    );
  }

  _TemporaryRedirect temporaryRedirect(
      {int intValue = RestResponseRedirectCodeType.temporaryRedirectIntValue}) {
    return _TemporaryRedirect(
      intValue: intValue,
    );
  }

  _PermanentRedirect permanentRedirect(
      {int intValue = RestResponseRedirectCodeType.permanentRedirectIntValue}) {
    return _PermanentRedirect(
      intValue: intValue,
    );
  }
}

/// @nodoc
const $RestResponseRedirectCodeType = _$RestResponseRedirectCodeTypeTearOff();

/// @nodoc
mixin _$RestResponseRedirectCodeType {
  int get intValue => throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $RestResponseRedirectCodeTypeCopyWith<RestResponseRedirectCodeType>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory $RestResponseRedirectCodeTypeCopyWith(
          RestResponseRedirectCodeType value,
          $Res Function(RestResponseRedirectCodeType) then) =
      _$RestResponseRedirectCodeTypeCopyWithImpl<$Res>;
  $Res call({int intValue});
}

/// @nodoc
class _$RestResponseRedirectCodeTypeCopyWithImpl<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  _$RestResponseRedirectCodeTypeCopyWithImpl(this._value, this._then);

  final RestResponseRedirectCodeType _value;
  // ignore: unused_field
  final $Res Function(RestResponseRedirectCodeType) _then;

  @override
  $Res call({
    Object? intValue = freezed,
  }) {
    return _then(_value.copyWith(
      intValue: intValue == freezed
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc
abstract class _$MultipleChoiceCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$MultipleChoiceCopyWith(
          _MultipleChoice value, $Res Function(_MultipleChoice) then) =
      __$MultipleChoiceCopyWithImpl<$Res>;
  @override
  $Res call({int intValue});
}

/// @nodoc
class __$MultipleChoiceCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res>
    implements _$MultipleChoiceCopyWith<$Res> {
  __$MultipleChoiceCopyWithImpl(
      _MultipleChoice _value, $Res Function(_MultipleChoice) _then)
      : super(_value, (v) => _then(v as _MultipleChoice));

  @override
  _MultipleChoice get _value => super._value as _MultipleChoice;

  @override
  $Res call({
    Object? intValue = freezed,
  }) {
    return _then(_MultipleChoice(
      intValue: intValue == freezed
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_MultipleChoice implements _MultipleChoice {
  const _$_MultipleChoice(
      {this.intValue = RestResponseRedirectCodeType.multipleChoiceIntValue});

  @JsonKey(defaultValue: RestResponseRedirectCodeType.multipleChoiceIntValue)
  @override
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.multipleChoice(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _MultipleChoice &&
            (identical(other.intValue, intValue) ||
                const DeepCollectionEquality()
                    .equals(other.intValue, intValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(intValue);

  @JsonKey(ignore: true)
  @override
  _$MultipleChoiceCopyWith<_MultipleChoice> get copyWith =>
      __$MultipleChoiceCopyWithImpl<_MultipleChoice>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return multipleChoice(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
  }) {
    return multipleChoice?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (multipleChoice != null) {
      return multipleChoice(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return multipleChoice(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return multipleChoice?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (multipleChoice != null) {
      return multipleChoice(this);
    }
    return orElse();
  }
}

abstract class _MultipleChoice implements RestResponseRedirectCodeType {
  const factory _MultipleChoice({int intValue}) = _$_MultipleChoice;

  @override
  int get intValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$MultipleChoiceCopyWith<_MultipleChoice> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$MovedCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$MovedCopyWith(_Moved value, $Res Function(_Moved) then) =
      __$MovedCopyWithImpl<$Res>;
  @override
  $Res call({int intValue});
}

/// @nodoc
class __$MovedCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res>
    implements _$MovedCopyWith<$Res> {
  __$MovedCopyWithImpl(_Moved _value, $Res Function(_Moved) _then)
      : super(_value, (v) => _then(v as _Moved));

  @override
  _Moved get _value => super._value as _Moved;

  @override
  $Res call({
    Object? intValue = freezed,
  }) {
    return _then(_Moved(
      intValue: intValue == freezed
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Moved implements _Moved {
  const _$_Moved({this.intValue = RestResponseRedirectCodeType.movedIntValue});

  @JsonKey(defaultValue: RestResponseRedirectCodeType.movedIntValue)
  @override
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.moved(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Moved &&
            (identical(other.intValue, intValue) ||
                const DeepCollectionEquality()
                    .equals(other.intValue, intValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(intValue);

  @JsonKey(ignore: true)
  @override
  _$MovedCopyWith<_Moved> get copyWith =>
      __$MovedCopyWithImpl<_Moved>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return moved(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
  }) {
    return moved?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (moved != null) {
      return moved(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return moved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return moved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (moved != null) {
      return moved(this);
    }
    return orElse();
  }
}

abstract class _Moved implements RestResponseRedirectCodeType {
  const factory _Moved({int intValue}) = _$_Moved;

  @override
  int get intValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$MovedCopyWith<_Moved> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$FoundCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$FoundCopyWith(_Found value, $Res Function(_Found) then) =
      __$FoundCopyWithImpl<$Res>;
  @override
  $Res call({int intValue});
}

/// @nodoc
class __$FoundCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res>
    implements _$FoundCopyWith<$Res> {
  __$FoundCopyWithImpl(_Found _value, $Res Function(_Found) _then)
      : super(_value, (v) => _then(v as _Found));

  @override
  _Found get _value => super._value as _Found;

  @override
  $Res call({
    Object? intValue = freezed,
  }) {
    return _then(_Found(
      intValue: intValue == freezed
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Found implements _Found {
  const _$_Found({this.intValue = RestResponseRedirectCodeType.foundIntValue});

  @JsonKey(defaultValue: RestResponseRedirectCodeType.foundIntValue)
  @override
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.found(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Found &&
            (identical(other.intValue, intValue) ||
                const DeepCollectionEquality()
                    .equals(other.intValue, intValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(intValue);

  @JsonKey(ignore: true)
  @override
  _$FoundCopyWith<_Found> get copyWith =>
      __$FoundCopyWithImpl<_Found>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return found(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
  }) {
    return found?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (found != null) {
      return found(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return found(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return found?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (found != null) {
      return found(this);
    }
    return orElse();
  }
}

abstract class _Found implements RestResponseRedirectCodeType {
  const factory _Found({int intValue}) = _$_Found;

  @override
  int get intValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$FoundCopyWith<_Found> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$SeeOtherCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$SeeOtherCopyWith(_SeeOther value, $Res Function(_SeeOther) then) =
      __$SeeOtherCopyWithImpl<$Res>;
  @override
  $Res call({int intValue});
}

/// @nodoc
class __$SeeOtherCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res>
    implements _$SeeOtherCopyWith<$Res> {
  __$SeeOtherCopyWithImpl(_SeeOther _value, $Res Function(_SeeOther) _then)
      : super(_value, (v) => _then(v as _SeeOther));

  @override
  _SeeOther get _value => super._value as _SeeOther;

  @override
  $Res call({
    Object? intValue = freezed,
  }) {
    return _then(_SeeOther(
      intValue: intValue == freezed
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_SeeOther implements _SeeOther {
  const _$_SeeOther(
      {this.intValue = RestResponseRedirectCodeType.seeOtherIntValue});

  @JsonKey(defaultValue: RestResponseRedirectCodeType.seeOtherIntValue)
  @override
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.seeOther(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _SeeOther &&
            (identical(other.intValue, intValue) ||
                const DeepCollectionEquality()
                    .equals(other.intValue, intValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(intValue);

  @JsonKey(ignore: true)
  @override
  _$SeeOtherCopyWith<_SeeOther> get copyWith =>
      __$SeeOtherCopyWithImpl<_SeeOther>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return seeOther(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
  }) {
    return seeOther?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (seeOther != null) {
      return seeOther(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return seeOther(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return seeOther?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (seeOther != null) {
      return seeOther(this);
    }
    return orElse();
  }
}

abstract class _SeeOther implements RestResponseRedirectCodeType {
  const factory _SeeOther({int intValue}) = _$_SeeOther;

  @override
  int get intValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$SeeOtherCopyWith<_SeeOther> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$NotModifiedCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$NotModifiedCopyWith(
          _NotModified value, $Res Function(_NotModified) then) =
      __$NotModifiedCopyWithImpl<$Res>;
  @override
  $Res call({int intValue});
}

/// @nodoc
class __$NotModifiedCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res>
    implements _$NotModifiedCopyWith<$Res> {
  __$NotModifiedCopyWithImpl(
      _NotModified _value, $Res Function(_NotModified) _then)
      : super(_value, (v) => _then(v as _NotModified));

  @override
  _NotModified get _value => super._value as _NotModified;

  @override
  $Res call({
    Object? intValue = freezed,
  }) {
    return _then(_NotModified(
      intValue: intValue == freezed
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_NotModified implements _NotModified {
  const _$_NotModified(
      {this.intValue = RestResponseRedirectCodeType.notModifiedIntValue});

  @JsonKey(defaultValue: RestResponseRedirectCodeType.notModifiedIntValue)
  @override
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.notModified(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _NotModified &&
            (identical(other.intValue, intValue) ||
                const DeepCollectionEquality()
                    .equals(other.intValue, intValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(intValue);

  @JsonKey(ignore: true)
  @override
  _$NotModifiedCopyWith<_NotModified> get copyWith =>
      __$NotModifiedCopyWithImpl<_NotModified>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return notModified(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
  }) {
    return notModified?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (notModified != null) {
      return notModified(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return notModified(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return notModified?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (notModified != null) {
      return notModified(this);
    }
    return orElse();
  }
}

abstract class _NotModified implements RestResponseRedirectCodeType {
  const factory _NotModified({int intValue}) = _$_NotModified;

  @override
  int get intValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$NotModifiedCopyWith<_NotModified> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$UseProxyCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$UseProxyCopyWith(_UseProxy value, $Res Function(_UseProxy) then) =
      __$UseProxyCopyWithImpl<$Res>;
  @override
  $Res call({int intValue});
}

/// @nodoc
class __$UseProxyCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res>
    implements _$UseProxyCopyWith<$Res> {
  __$UseProxyCopyWithImpl(_UseProxy _value, $Res Function(_UseProxy) _then)
      : super(_value, (v) => _then(v as _UseProxy));

  @override
  _UseProxy get _value => super._value as _UseProxy;

  @override
  $Res call({
    Object? intValue = freezed,
  }) {
    return _then(_UseProxy(
      intValue: intValue == freezed
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_UseProxy implements _UseProxy {
  const _$_UseProxy(
      {this.intValue = RestResponseRedirectCodeType.useProxyIntValue});

  @JsonKey(defaultValue: RestResponseRedirectCodeType.useProxyIntValue)
  @override
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.useProxy(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _UseProxy &&
            (identical(other.intValue, intValue) ||
                const DeepCollectionEquality()
                    .equals(other.intValue, intValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(intValue);

  @JsonKey(ignore: true)
  @override
  _$UseProxyCopyWith<_UseProxy> get copyWith =>
      __$UseProxyCopyWithImpl<_UseProxy>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return useProxy(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
  }) {
    return useProxy?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (useProxy != null) {
      return useProxy(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return useProxy(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return useProxy?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (useProxy != null) {
      return useProxy(this);
    }
    return orElse();
  }
}

abstract class _UseProxy implements RestResponseRedirectCodeType {
  const factory _UseProxy({int intValue}) = _$_UseProxy;

  @override
  int get intValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$UseProxyCopyWith<_UseProxy> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$UnusedCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$UnusedCopyWith(_Unused value, $Res Function(_Unused) then) =
      __$UnusedCopyWithImpl<$Res>;
  @override
  $Res call({int intValue});
}

/// @nodoc
class __$UnusedCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res>
    implements _$UnusedCopyWith<$Res> {
  __$UnusedCopyWithImpl(_Unused _value, $Res Function(_Unused) _then)
      : super(_value, (v) => _then(v as _Unused));

  @override
  _Unused get _value => super._value as _Unused;

  @override
  $Res call({
    Object? intValue = freezed,
  }) {
    return _then(_Unused(
      intValue: intValue == freezed
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Unused implements _Unused {
  const _$_Unused(
      {this.intValue = RestResponseRedirectCodeType.unusedIntValue});

  @JsonKey(defaultValue: RestResponseRedirectCodeType.unusedIntValue)
  @override
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.unused(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Unused &&
            (identical(other.intValue, intValue) ||
                const DeepCollectionEquality()
                    .equals(other.intValue, intValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(intValue);

  @JsonKey(ignore: true)
  @override
  _$UnusedCopyWith<_Unused> get copyWith =>
      __$UnusedCopyWithImpl<_Unused>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return unused(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
  }) {
    return unused?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (unused != null) {
      return unused(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return unused(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return unused?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (unused != null) {
      return unused(this);
    }
    return orElse();
  }
}

abstract class _Unused implements RestResponseRedirectCodeType {
  const factory _Unused({int intValue}) = _$_Unused;

  @override
  int get intValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$UnusedCopyWith<_Unused> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$TemporaryRedirectCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$TemporaryRedirectCopyWith(
          _TemporaryRedirect value, $Res Function(_TemporaryRedirect) then) =
      __$TemporaryRedirectCopyWithImpl<$Res>;
  @override
  $Res call({int intValue});
}

/// @nodoc
class __$TemporaryRedirectCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res>
    implements _$TemporaryRedirectCopyWith<$Res> {
  __$TemporaryRedirectCopyWithImpl(
      _TemporaryRedirect _value, $Res Function(_TemporaryRedirect) _then)
      : super(_value, (v) => _then(v as _TemporaryRedirect));

  @override
  _TemporaryRedirect get _value => super._value as _TemporaryRedirect;

  @override
  $Res call({
    Object? intValue = freezed,
  }) {
    return _then(_TemporaryRedirect(
      intValue: intValue == freezed
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_TemporaryRedirect implements _TemporaryRedirect {
  const _$_TemporaryRedirect(
      {this.intValue = RestResponseRedirectCodeType.temporaryRedirectIntValue});

  @JsonKey(defaultValue: RestResponseRedirectCodeType.temporaryRedirectIntValue)
  @override
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.temporaryRedirect(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TemporaryRedirect &&
            (identical(other.intValue, intValue) ||
                const DeepCollectionEquality()
                    .equals(other.intValue, intValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(intValue);

  @JsonKey(ignore: true)
  @override
  _$TemporaryRedirectCopyWith<_TemporaryRedirect> get copyWith =>
      __$TemporaryRedirectCopyWithImpl<_TemporaryRedirect>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return temporaryRedirect(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
  }) {
    return temporaryRedirect?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (temporaryRedirect != null) {
      return temporaryRedirect(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return temporaryRedirect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return temporaryRedirect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (temporaryRedirect != null) {
      return temporaryRedirect(this);
    }
    return orElse();
  }
}

abstract class _TemporaryRedirect implements RestResponseRedirectCodeType {
  const factory _TemporaryRedirect({int intValue}) = _$_TemporaryRedirect;

  @override
  int get intValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$TemporaryRedirectCopyWith<_TemporaryRedirect> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$PermanentRedirectCopyWith<$Res>
    implements $RestResponseRedirectCodeTypeCopyWith<$Res> {
  factory _$PermanentRedirectCopyWith(
          _PermanentRedirect value, $Res Function(_PermanentRedirect) then) =
      __$PermanentRedirectCopyWithImpl<$Res>;
  @override
  $Res call({int intValue});
}

/// @nodoc
class __$PermanentRedirectCopyWithImpl<$Res>
    extends _$RestResponseRedirectCodeTypeCopyWithImpl<$Res>
    implements _$PermanentRedirectCopyWith<$Res> {
  __$PermanentRedirectCopyWithImpl(
      _PermanentRedirect _value, $Res Function(_PermanentRedirect) _then)
      : super(_value, (v) => _then(v as _PermanentRedirect));

  @override
  _PermanentRedirect get _value => super._value as _PermanentRedirect;

  @override
  $Res call({
    Object? intValue = freezed,
  }) {
    return _then(_PermanentRedirect(
      intValue: intValue == freezed
          ? _value.intValue
          : intValue // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_PermanentRedirect implements _PermanentRedirect {
  const _$_PermanentRedirect(
      {this.intValue = RestResponseRedirectCodeType.permanentRedirectIntValue});

  @JsonKey(defaultValue: RestResponseRedirectCodeType.permanentRedirectIntValue)
  @override
  final int intValue;

  @override
  String toString() {
    return 'RestResponseRedirectCodeType.permanentRedirect(intValue: $intValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _PermanentRedirect &&
            (identical(other.intValue, intValue) ||
                const DeepCollectionEquality()
                    .equals(other.intValue, intValue)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(intValue);

  @JsonKey(ignore: true)
  @override
  _$PermanentRedirectCopyWith<_PermanentRedirect> get copyWith =>
      __$PermanentRedirectCopyWithImpl<_PermanentRedirect>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int intValue) multipleChoice,
    required TResult Function(int intValue) moved,
    required TResult Function(int intValue) found,
    required TResult Function(int intValue) seeOther,
    required TResult Function(int intValue) notModified,
    required TResult Function(int intValue) useProxy,
    required TResult Function(int intValue) unused,
    required TResult Function(int intValue) temporaryRedirect,
    required TResult Function(int intValue) permanentRedirect,
  }) {
    return permanentRedirect(intValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
  }) {
    return permanentRedirect?.call(intValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int intValue)? multipleChoice,
    TResult Function(int intValue)? moved,
    TResult Function(int intValue)? found,
    TResult Function(int intValue)? seeOther,
    TResult Function(int intValue)? notModified,
    TResult Function(int intValue)? useProxy,
    TResult Function(int intValue)? unused,
    TResult Function(int intValue)? temporaryRedirect,
    TResult Function(int intValue)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (permanentRedirect != null) {
      return permanentRedirect(intValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_MultipleChoice value) multipleChoice,
    required TResult Function(_Moved value) moved,
    required TResult Function(_Found value) found,
    required TResult Function(_SeeOther value) seeOther,
    required TResult Function(_NotModified value) notModified,
    required TResult Function(_UseProxy value) useProxy,
    required TResult Function(_Unused value) unused,
    required TResult Function(_TemporaryRedirect value) temporaryRedirect,
    required TResult Function(_PermanentRedirect value) permanentRedirect,
  }) {
    return permanentRedirect(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
  }) {
    return permanentRedirect?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_MultipleChoice value)? multipleChoice,
    TResult Function(_Moved value)? moved,
    TResult Function(_Found value)? found,
    TResult Function(_SeeOther value)? seeOther,
    TResult Function(_NotModified value)? notModified,
    TResult Function(_UseProxy value)? useProxy,
    TResult Function(_Unused value)? unused,
    TResult Function(_TemporaryRedirect value)? temporaryRedirect,
    TResult Function(_PermanentRedirect value)? permanentRedirect,
    required TResult orElse(),
  }) {
    if (permanentRedirect != null) {
      return permanentRedirect(this);
    }
    return orElse();
  }
}

abstract class _PermanentRedirect implements RestResponseRedirectCodeType {
  const factory _PermanentRedirect({int intValue}) = _$_PermanentRedirect;

  @override
  int get intValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$PermanentRedirectCopyWith<_PermanentRedirect> get copyWith =>
      throw _privateConstructorUsedError;
}
