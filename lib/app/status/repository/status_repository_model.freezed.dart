// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'status_repository_model.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$UnifediApiReplyVisibilityFilterConditionTearOff {
  const _$UnifediApiReplyVisibilityFilterConditionTearOff();

  _UnifediApiReplyVisibilityFilterCondition call(
      {required String? myAccountRemoteId,
      required UnifediApiReplyVisibilityFilter? replyVisibilityFilter}) {
    return _UnifediApiReplyVisibilityFilterCondition(
      myAccountRemoteId: myAccountRemoteId,
      replyVisibilityFilter: replyVisibilityFilter,
    );
  }
}

/// @nodoc
const $UnifediApiReplyVisibilityFilterCondition =
    _$UnifediApiReplyVisibilityFilterConditionTearOff();

/// @nodoc
mixin _$UnifediApiReplyVisibilityFilterCondition {
  String? get myAccountRemoteId => throw _privateConstructorUsedError;
  UnifediApiReplyVisibilityFilter? get replyVisibilityFilter =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $UnifediApiReplyVisibilityFilterConditionCopyWith<
          UnifediApiReplyVisibilityFilterCondition>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $UnifediApiReplyVisibilityFilterConditionCopyWith<$Res> {
  factory $UnifediApiReplyVisibilityFilterConditionCopyWith(
          UnifediApiReplyVisibilityFilterCondition value,
          $Res Function(UnifediApiReplyVisibilityFilterCondition) then) =
      _$UnifediApiReplyVisibilityFilterConditionCopyWithImpl<$Res>;
  $Res call(
      {String? myAccountRemoteId,
      UnifediApiReplyVisibilityFilter? replyVisibilityFilter});

  $UnifediApiReplyVisibilityFilterCopyWith<$Res>? get replyVisibilityFilter;
}

/// @nodoc
class _$UnifediApiReplyVisibilityFilterConditionCopyWithImpl<$Res>
    implements $UnifediApiReplyVisibilityFilterConditionCopyWith<$Res> {
  _$UnifediApiReplyVisibilityFilterConditionCopyWithImpl(
      this._value, this._then);

  final UnifediApiReplyVisibilityFilterCondition _value;
  // ignore: unused_field
  final $Res Function(UnifediApiReplyVisibilityFilterCondition) _then;

  @override
  $Res call({
    Object? myAccountRemoteId = freezed,
    Object? replyVisibilityFilter = freezed,
  }) {
    return _then(_value.copyWith(
      myAccountRemoteId: myAccountRemoteId == freezed
          ? _value.myAccountRemoteId
          : myAccountRemoteId // ignore: cast_nullable_to_non_nullable
              as String?,
      replyVisibilityFilter: replyVisibilityFilter == freezed
          ? _value.replyVisibilityFilter
          : replyVisibilityFilter // ignore: cast_nullable_to_non_nullable
              as UnifediApiReplyVisibilityFilter?,
    ));
  }

  @override
  $UnifediApiReplyVisibilityFilterCopyWith<$Res>? get replyVisibilityFilter {
    if (_value.replyVisibilityFilter == null) {
      return null;
    }

    return $UnifediApiReplyVisibilityFilterCopyWith<$Res>(
        _value.replyVisibilityFilter!, (value) {
      return _then(_value.copyWith(replyVisibilityFilter: value));
    });
  }
}

/// @nodoc
abstract class _$UnifediApiReplyVisibilityFilterConditionCopyWith<$Res>
    implements $UnifediApiReplyVisibilityFilterConditionCopyWith<$Res> {
  factory _$UnifediApiReplyVisibilityFilterConditionCopyWith(
          _UnifediApiReplyVisibilityFilterCondition value,
          $Res Function(_UnifediApiReplyVisibilityFilterCondition) then) =
      __$UnifediApiReplyVisibilityFilterConditionCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? myAccountRemoteId,
      UnifediApiReplyVisibilityFilter? replyVisibilityFilter});

  @override
  $UnifediApiReplyVisibilityFilterCopyWith<$Res>? get replyVisibilityFilter;
}

/// @nodoc
class __$UnifediApiReplyVisibilityFilterConditionCopyWithImpl<$Res>
    extends _$UnifediApiReplyVisibilityFilterConditionCopyWithImpl<$Res>
    implements _$UnifediApiReplyVisibilityFilterConditionCopyWith<$Res> {
  __$UnifediApiReplyVisibilityFilterConditionCopyWithImpl(
      _UnifediApiReplyVisibilityFilterCondition _value,
      $Res Function(_UnifediApiReplyVisibilityFilterCondition) _then)
      : super(_value,
            (v) => _then(v as _UnifediApiReplyVisibilityFilterCondition));

  @override
  _UnifediApiReplyVisibilityFilterCondition get _value =>
      super._value as _UnifediApiReplyVisibilityFilterCondition;

  @override
  $Res call({
    Object? myAccountRemoteId = freezed,
    Object? replyVisibilityFilter = freezed,
  }) {
    return _then(_UnifediApiReplyVisibilityFilterCondition(
      myAccountRemoteId: myAccountRemoteId == freezed
          ? _value.myAccountRemoteId
          : myAccountRemoteId // ignore: cast_nullable_to_non_nullable
              as String?,
      replyVisibilityFilter: replyVisibilityFilter == freezed
          ? _value.replyVisibilityFilter
          : replyVisibilityFilter // ignore: cast_nullable_to_non_nullable
              as UnifediApiReplyVisibilityFilter?,
    ));
  }
}

/// @nodoc

class _$_UnifediApiReplyVisibilityFilterCondition
    implements _UnifediApiReplyVisibilityFilterCondition {
  const _$_UnifediApiReplyVisibilityFilterCondition(
      {required this.myAccountRemoteId, required this.replyVisibilityFilter});

  @override
  final String? myAccountRemoteId;
  @override
  final UnifediApiReplyVisibilityFilter? replyVisibilityFilter;

  @override
  String toString() {
    return 'UnifediApiReplyVisibilityFilterCondition(myAccountRemoteId: $myAccountRemoteId, replyVisibilityFilter: $replyVisibilityFilter)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _UnifediApiReplyVisibilityFilterCondition &&
            (identical(other.myAccountRemoteId, myAccountRemoteId) ||
                const DeepCollectionEquality()
                    .equals(other.myAccountRemoteId, myAccountRemoteId)) &&
            (identical(other.replyVisibilityFilter, replyVisibilityFilter) ||
                const DeepCollectionEquality().equals(
                    other.replyVisibilityFilter, replyVisibilityFilter)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(myAccountRemoteId) ^
      const DeepCollectionEquality().hash(replyVisibilityFilter);

  @JsonKey(ignore: true)
  @override
  _$UnifediApiReplyVisibilityFilterConditionCopyWith<
          _UnifediApiReplyVisibilityFilterCondition>
      get copyWith => __$UnifediApiReplyVisibilityFilterConditionCopyWithImpl<
          _UnifediApiReplyVisibilityFilterCondition>(this, _$identity);
}

abstract class _UnifediApiReplyVisibilityFilterCondition
    implements UnifediApiReplyVisibilityFilterCondition {
  const factory _UnifediApiReplyVisibilityFilterCondition(
          {required String? myAccountRemoteId,
          required UnifediApiReplyVisibilityFilter? replyVisibilityFilter}) =
      _$_UnifediApiReplyVisibilityFilterCondition;

  @override
  String? get myAccountRemoteId => throw _privateConstructorUsedError;
  @override
  UnifediApiReplyVisibilityFilter? get replyVisibilityFilter =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$UnifediApiReplyVisibilityFilterConditionCopyWith<
          _UnifediApiReplyVisibilityFilterCondition>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$StatusRepositoryFiltersTearOff {
  const _$StatusRepositoryFiltersTearOff();

  _StatusRepositoryFilters call(
      {required String? onlyInListWithRemoteId,
      required String? onlyWithHashtag,
      required IAccount? onlyFromAccountsFollowingByAccount,
      required IAccount? onlyFromAccount,
      required IConversationChat? onlyInConversation,
      required StatusOnlyLocalCondition? onlyLocalCondition,
      required bool? onlyWithMedia,
      required bool? withMuted,
      required List<UnifediApiVisibility>? excludeVisibilities,
      required bool? onlyNoNsfwSensitive,
      required bool? onlyNoReplies,
      required bool? isFromHomeTimeline,
      required bool? onlyFavourited,
      required bool? onlyBookmarked,
      required List<StatusTextCondition>? excludeTextConditions,
      bool onlyNotDeleted = true,
      bool onlyNotHiddenLocallyOnDevice = true,
      required StatusOnlyRemoteCondition? onlyRemoteCondition,
      bool mustBeConversationItem = false,
      required String? onlyFromInstance,
      required UnifediApiReplyVisibilityFilterCondition?
          replyVisibilityFilterCondition,
      bool onlyPendingStatePublishedOrNull = true}) {
    return _StatusRepositoryFilters(
      onlyInListWithRemoteId: onlyInListWithRemoteId,
      onlyWithHashtag: onlyWithHashtag,
      onlyFromAccountsFollowingByAccount: onlyFromAccountsFollowingByAccount,
      onlyFromAccount: onlyFromAccount,
      onlyInConversation: onlyInConversation,
      onlyLocalCondition: onlyLocalCondition,
      onlyWithMedia: onlyWithMedia,
      withMuted: withMuted,
      excludeVisibilities: excludeVisibilities,
      onlyNoNsfwSensitive: onlyNoNsfwSensitive,
      onlyNoReplies: onlyNoReplies,
      isFromHomeTimeline: isFromHomeTimeline,
      onlyFavourited: onlyFavourited,
      onlyBookmarked: onlyBookmarked,
      excludeTextConditions: excludeTextConditions,
      onlyNotDeleted: onlyNotDeleted,
      onlyNotHiddenLocallyOnDevice: onlyNotHiddenLocallyOnDevice,
      onlyRemoteCondition: onlyRemoteCondition,
      mustBeConversationItem: mustBeConversationItem,
      onlyFromInstance: onlyFromInstance,
      replyVisibilityFilterCondition: replyVisibilityFilterCondition,
      onlyPendingStatePublishedOrNull: onlyPendingStatePublishedOrNull,
    );
  }
}

/// @nodoc
const $StatusRepositoryFilters = _$StatusRepositoryFiltersTearOff();

/// @nodoc
mixin _$StatusRepositoryFilters {
  String? get onlyInListWithRemoteId => throw _privateConstructorUsedError;
  String? get onlyWithHashtag => throw _privateConstructorUsedError;
  IAccount? get onlyFromAccountsFollowingByAccount =>
      throw _privateConstructorUsedError;
  IAccount? get onlyFromAccount => throw _privateConstructorUsedError;
  IConversationChat? get onlyInConversation =>
      throw _privateConstructorUsedError;
  StatusOnlyLocalCondition? get onlyLocalCondition =>
      throw _privateConstructorUsedError;
  bool? get onlyWithMedia => throw _privateConstructorUsedError;
  bool? get withMuted => throw _privateConstructorUsedError;
  List<UnifediApiVisibility>? get excludeVisibilities =>
      throw _privateConstructorUsedError;
  bool? get onlyNoNsfwSensitive => throw _privateConstructorUsedError;
  bool? get onlyNoReplies => throw _privateConstructorUsedError;
  bool? get isFromHomeTimeline => throw _privateConstructorUsedError;
  bool? get onlyFavourited => throw _privateConstructorUsedError;
  bool? get onlyBookmarked => throw _privateConstructorUsedError;
  List<StatusTextCondition>? get excludeTextConditions =>
      throw _privateConstructorUsedError;
  bool get onlyNotDeleted => throw _privateConstructorUsedError;
  bool get onlyNotHiddenLocallyOnDevice => throw _privateConstructorUsedError;
  StatusOnlyRemoteCondition? get onlyRemoteCondition =>
      throw _privateConstructorUsedError;
  bool get mustBeConversationItem => throw _privateConstructorUsedError;
  String? get onlyFromInstance => throw _privateConstructorUsedError;
  UnifediApiReplyVisibilityFilterCondition?
      get replyVisibilityFilterCondition => throw _privateConstructorUsedError;
  bool get onlyPendingStatePublishedOrNull =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StatusRepositoryFiltersCopyWith<StatusRepositoryFilters> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StatusRepositoryFiltersCopyWith<$Res> {
  factory $StatusRepositoryFiltersCopyWith(StatusRepositoryFilters value,
          $Res Function(StatusRepositoryFilters) then) =
      _$StatusRepositoryFiltersCopyWithImpl<$Res>;
  $Res call(
      {String? onlyInListWithRemoteId,
      String? onlyWithHashtag,
      IAccount? onlyFromAccountsFollowingByAccount,
      IAccount? onlyFromAccount,
      IConversationChat? onlyInConversation,
      StatusOnlyLocalCondition? onlyLocalCondition,
      bool? onlyWithMedia,
      bool? withMuted,
      List<UnifediApiVisibility>? excludeVisibilities,
      bool? onlyNoNsfwSensitive,
      bool? onlyNoReplies,
      bool? isFromHomeTimeline,
      bool? onlyFavourited,
      bool? onlyBookmarked,
      List<StatusTextCondition>? excludeTextConditions,
      bool onlyNotDeleted,
      bool onlyNotHiddenLocallyOnDevice,
      StatusOnlyRemoteCondition? onlyRemoteCondition,
      bool mustBeConversationItem,
      String? onlyFromInstance,
      UnifediApiReplyVisibilityFilterCondition? replyVisibilityFilterCondition,
      bool onlyPendingStatePublishedOrNull});

  $StatusOnlyLocalConditionCopyWith<$Res>? get onlyLocalCondition;
  $StatusOnlyRemoteConditionCopyWith<$Res>? get onlyRemoteCondition;
  $UnifediApiReplyVisibilityFilterConditionCopyWith<$Res>?
      get replyVisibilityFilterCondition;
}

/// @nodoc
class _$StatusRepositoryFiltersCopyWithImpl<$Res>
    implements $StatusRepositoryFiltersCopyWith<$Res> {
  _$StatusRepositoryFiltersCopyWithImpl(this._value, this._then);

  final StatusRepositoryFilters _value;
  // ignore: unused_field
  final $Res Function(StatusRepositoryFilters) _then;

  @override
  $Res call({
    Object? onlyInListWithRemoteId = freezed,
    Object? onlyWithHashtag = freezed,
    Object? onlyFromAccountsFollowingByAccount = freezed,
    Object? onlyFromAccount = freezed,
    Object? onlyInConversation = freezed,
    Object? onlyLocalCondition = freezed,
    Object? onlyWithMedia = freezed,
    Object? withMuted = freezed,
    Object? excludeVisibilities = freezed,
    Object? onlyNoNsfwSensitive = freezed,
    Object? onlyNoReplies = freezed,
    Object? isFromHomeTimeline = freezed,
    Object? onlyFavourited = freezed,
    Object? onlyBookmarked = freezed,
    Object? excludeTextConditions = freezed,
    Object? onlyNotDeleted = freezed,
    Object? onlyNotHiddenLocallyOnDevice = freezed,
    Object? onlyRemoteCondition = freezed,
    Object? mustBeConversationItem = freezed,
    Object? onlyFromInstance = freezed,
    Object? replyVisibilityFilterCondition = freezed,
    Object? onlyPendingStatePublishedOrNull = freezed,
  }) {
    return _then(_value.copyWith(
      onlyInListWithRemoteId: onlyInListWithRemoteId == freezed
          ? _value.onlyInListWithRemoteId
          : onlyInListWithRemoteId // ignore: cast_nullable_to_non_nullable
              as String?,
      onlyWithHashtag: onlyWithHashtag == freezed
          ? _value.onlyWithHashtag
          : onlyWithHashtag // ignore: cast_nullable_to_non_nullable
              as String?,
      onlyFromAccountsFollowingByAccount: onlyFromAccountsFollowingByAccount ==
              freezed
          ? _value.onlyFromAccountsFollowingByAccount
          : onlyFromAccountsFollowingByAccount // ignore: cast_nullable_to_non_nullable
              as IAccount?,
      onlyFromAccount: onlyFromAccount == freezed
          ? _value.onlyFromAccount
          : onlyFromAccount // ignore: cast_nullable_to_non_nullable
              as IAccount?,
      onlyInConversation: onlyInConversation == freezed
          ? _value.onlyInConversation
          : onlyInConversation // ignore: cast_nullable_to_non_nullable
              as IConversationChat?,
      onlyLocalCondition: onlyLocalCondition == freezed
          ? _value.onlyLocalCondition
          : onlyLocalCondition // ignore: cast_nullable_to_non_nullable
              as StatusOnlyLocalCondition?,
      onlyWithMedia: onlyWithMedia == freezed
          ? _value.onlyWithMedia
          : onlyWithMedia // ignore: cast_nullable_to_non_nullable
              as bool?,
      withMuted: withMuted == freezed
          ? _value.withMuted
          : withMuted // ignore: cast_nullable_to_non_nullable
              as bool?,
      excludeVisibilities: excludeVisibilities == freezed
          ? _value.excludeVisibilities
          : excludeVisibilities // ignore: cast_nullable_to_non_nullable
              as List<UnifediApiVisibility>?,
      onlyNoNsfwSensitive: onlyNoNsfwSensitive == freezed
          ? _value.onlyNoNsfwSensitive
          : onlyNoNsfwSensitive // ignore: cast_nullable_to_non_nullable
              as bool?,
      onlyNoReplies: onlyNoReplies == freezed
          ? _value.onlyNoReplies
          : onlyNoReplies // ignore: cast_nullable_to_non_nullable
              as bool?,
      isFromHomeTimeline: isFromHomeTimeline == freezed
          ? _value.isFromHomeTimeline
          : isFromHomeTimeline // ignore: cast_nullable_to_non_nullable
              as bool?,
      onlyFavourited: onlyFavourited == freezed
          ? _value.onlyFavourited
          : onlyFavourited // ignore: cast_nullable_to_non_nullable
              as bool?,
      onlyBookmarked: onlyBookmarked == freezed
          ? _value.onlyBookmarked
          : onlyBookmarked // ignore: cast_nullable_to_non_nullable
              as bool?,
      excludeTextConditions: excludeTextConditions == freezed
          ? _value.excludeTextConditions
          : excludeTextConditions // ignore: cast_nullable_to_non_nullable
              as List<StatusTextCondition>?,
      onlyNotDeleted: onlyNotDeleted == freezed
          ? _value.onlyNotDeleted
          : onlyNotDeleted // ignore: cast_nullable_to_non_nullable
              as bool,
      onlyNotHiddenLocallyOnDevice: onlyNotHiddenLocallyOnDevice == freezed
          ? _value.onlyNotHiddenLocallyOnDevice
          : onlyNotHiddenLocallyOnDevice // ignore: cast_nullable_to_non_nullable
              as bool,
      onlyRemoteCondition: onlyRemoteCondition == freezed
          ? _value.onlyRemoteCondition
          : onlyRemoteCondition // ignore: cast_nullable_to_non_nullable
              as StatusOnlyRemoteCondition?,
      mustBeConversationItem: mustBeConversationItem == freezed
          ? _value.mustBeConversationItem
          : mustBeConversationItem // ignore: cast_nullable_to_non_nullable
              as bool,
      onlyFromInstance: onlyFromInstance == freezed
          ? _value.onlyFromInstance
          : onlyFromInstance // ignore: cast_nullable_to_non_nullable
              as String?,
      replyVisibilityFilterCondition: replyVisibilityFilterCondition == freezed
          ? _value.replyVisibilityFilterCondition
          : replyVisibilityFilterCondition // ignore: cast_nullable_to_non_nullable
              as UnifediApiReplyVisibilityFilterCondition?,
      onlyPendingStatePublishedOrNull: onlyPendingStatePublishedOrNull ==
              freezed
          ? _value.onlyPendingStatePublishedOrNull
          : onlyPendingStatePublishedOrNull // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }

  @override
  $StatusOnlyLocalConditionCopyWith<$Res>? get onlyLocalCondition {
    if (_value.onlyLocalCondition == null) {
      return null;
    }

    return $StatusOnlyLocalConditionCopyWith<$Res>(_value.onlyLocalCondition!,
        (value) {
      return _then(_value.copyWith(onlyLocalCondition: value));
    });
  }

  @override
  $StatusOnlyRemoteConditionCopyWith<$Res>? get onlyRemoteCondition {
    if (_value.onlyRemoteCondition == null) {
      return null;
    }

    return $StatusOnlyRemoteConditionCopyWith<$Res>(_value.onlyRemoteCondition!,
        (value) {
      return _then(_value.copyWith(onlyRemoteCondition: value));
    });
  }

  @override
  $UnifediApiReplyVisibilityFilterConditionCopyWith<$Res>?
      get replyVisibilityFilterCondition {
    if (_value.replyVisibilityFilterCondition == null) {
      return null;
    }

    return $UnifediApiReplyVisibilityFilterConditionCopyWith<$Res>(
        _value.replyVisibilityFilterCondition!, (value) {
      return _then(_value.copyWith(replyVisibilityFilterCondition: value));
    });
  }
}

/// @nodoc
abstract class _$StatusRepositoryFiltersCopyWith<$Res>
    implements $StatusRepositoryFiltersCopyWith<$Res> {
  factory _$StatusRepositoryFiltersCopyWith(_StatusRepositoryFilters value,
          $Res Function(_StatusRepositoryFilters) then) =
      __$StatusRepositoryFiltersCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? onlyInListWithRemoteId,
      String? onlyWithHashtag,
      IAccount? onlyFromAccountsFollowingByAccount,
      IAccount? onlyFromAccount,
      IConversationChat? onlyInConversation,
      StatusOnlyLocalCondition? onlyLocalCondition,
      bool? onlyWithMedia,
      bool? withMuted,
      List<UnifediApiVisibility>? excludeVisibilities,
      bool? onlyNoNsfwSensitive,
      bool? onlyNoReplies,
      bool? isFromHomeTimeline,
      bool? onlyFavourited,
      bool? onlyBookmarked,
      List<StatusTextCondition>? excludeTextConditions,
      bool onlyNotDeleted,
      bool onlyNotHiddenLocallyOnDevice,
      StatusOnlyRemoteCondition? onlyRemoteCondition,
      bool mustBeConversationItem,
      String? onlyFromInstance,
      UnifediApiReplyVisibilityFilterCondition? replyVisibilityFilterCondition,
      bool onlyPendingStatePublishedOrNull});

  @override
  $StatusOnlyLocalConditionCopyWith<$Res>? get onlyLocalCondition;
  @override
  $StatusOnlyRemoteConditionCopyWith<$Res>? get onlyRemoteCondition;
  @override
  $UnifediApiReplyVisibilityFilterConditionCopyWith<$Res>?
      get replyVisibilityFilterCondition;
}

/// @nodoc
class __$StatusRepositoryFiltersCopyWithImpl<$Res>
    extends _$StatusRepositoryFiltersCopyWithImpl<$Res>
    implements _$StatusRepositoryFiltersCopyWith<$Res> {
  __$StatusRepositoryFiltersCopyWithImpl(_StatusRepositoryFilters _value,
      $Res Function(_StatusRepositoryFilters) _then)
      : super(_value, (v) => _then(v as _StatusRepositoryFilters));

  @override
  _StatusRepositoryFilters get _value =>
      super._value as _StatusRepositoryFilters;

  @override
  $Res call({
    Object? onlyInListWithRemoteId = freezed,
    Object? onlyWithHashtag = freezed,
    Object? onlyFromAccountsFollowingByAccount = freezed,
    Object? onlyFromAccount = freezed,
    Object? onlyInConversation = freezed,
    Object? onlyLocalCondition = freezed,
    Object? onlyWithMedia = freezed,
    Object? withMuted = freezed,
    Object? excludeVisibilities = freezed,
    Object? onlyNoNsfwSensitive = freezed,
    Object? onlyNoReplies = freezed,
    Object? isFromHomeTimeline = freezed,
    Object? onlyFavourited = freezed,
    Object? onlyBookmarked = freezed,
    Object? excludeTextConditions = freezed,
    Object? onlyNotDeleted = freezed,
    Object? onlyNotHiddenLocallyOnDevice = freezed,
    Object? onlyRemoteCondition = freezed,
    Object? mustBeConversationItem = freezed,
    Object? onlyFromInstance = freezed,
    Object? replyVisibilityFilterCondition = freezed,
    Object? onlyPendingStatePublishedOrNull = freezed,
  }) {
    return _then(_StatusRepositoryFilters(
      onlyInListWithRemoteId: onlyInListWithRemoteId == freezed
          ? _value.onlyInListWithRemoteId
          : onlyInListWithRemoteId // ignore: cast_nullable_to_non_nullable
              as String?,
      onlyWithHashtag: onlyWithHashtag == freezed
          ? _value.onlyWithHashtag
          : onlyWithHashtag // ignore: cast_nullable_to_non_nullable
              as String?,
      onlyFromAccountsFollowingByAccount: onlyFromAccountsFollowingByAccount ==
              freezed
          ? _value.onlyFromAccountsFollowingByAccount
          : onlyFromAccountsFollowingByAccount // ignore: cast_nullable_to_non_nullable
              as IAccount?,
      onlyFromAccount: onlyFromAccount == freezed
          ? _value.onlyFromAccount
          : onlyFromAccount // ignore: cast_nullable_to_non_nullable
              as IAccount?,
      onlyInConversation: onlyInConversation == freezed
          ? _value.onlyInConversation
          : onlyInConversation // ignore: cast_nullable_to_non_nullable
              as IConversationChat?,
      onlyLocalCondition: onlyLocalCondition == freezed
          ? _value.onlyLocalCondition
          : onlyLocalCondition // ignore: cast_nullable_to_non_nullable
              as StatusOnlyLocalCondition?,
      onlyWithMedia: onlyWithMedia == freezed
          ? _value.onlyWithMedia
          : onlyWithMedia // ignore: cast_nullable_to_non_nullable
              as bool?,
      withMuted: withMuted == freezed
          ? _value.withMuted
          : withMuted // ignore: cast_nullable_to_non_nullable
              as bool?,
      excludeVisibilities: excludeVisibilities == freezed
          ? _value.excludeVisibilities
          : excludeVisibilities // ignore: cast_nullable_to_non_nullable
              as List<UnifediApiVisibility>?,
      onlyNoNsfwSensitive: onlyNoNsfwSensitive == freezed
          ? _value.onlyNoNsfwSensitive
          : onlyNoNsfwSensitive // ignore: cast_nullable_to_non_nullable
              as bool?,
      onlyNoReplies: onlyNoReplies == freezed
          ? _value.onlyNoReplies
          : onlyNoReplies // ignore: cast_nullable_to_non_nullable
              as bool?,
      isFromHomeTimeline: isFromHomeTimeline == freezed
          ? _value.isFromHomeTimeline
          : isFromHomeTimeline // ignore: cast_nullable_to_non_nullable
              as bool?,
      onlyFavourited: onlyFavourited == freezed
          ? _value.onlyFavourited
          : onlyFavourited // ignore: cast_nullable_to_non_nullable
              as bool?,
      onlyBookmarked: onlyBookmarked == freezed
          ? _value.onlyBookmarked
          : onlyBookmarked // ignore: cast_nullable_to_non_nullable
              as bool?,
      excludeTextConditions: excludeTextConditions == freezed
          ? _value.excludeTextConditions
          : excludeTextConditions // ignore: cast_nullable_to_non_nullable
              as List<StatusTextCondition>?,
      onlyNotDeleted: onlyNotDeleted == freezed
          ? _value.onlyNotDeleted
          : onlyNotDeleted // ignore: cast_nullable_to_non_nullable
              as bool,
      onlyNotHiddenLocallyOnDevice: onlyNotHiddenLocallyOnDevice == freezed
          ? _value.onlyNotHiddenLocallyOnDevice
          : onlyNotHiddenLocallyOnDevice // ignore: cast_nullable_to_non_nullable
              as bool,
      onlyRemoteCondition: onlyRemoteCondition == freezed
          ? _value.onlyRemoteCondition
          : onlyRemoteCondition // ignore: cast_nullable_to_non_nullable
              as StatusOnlyRemoteCondition?,
      mustBeConversationItem: mustBeConversationItem == freezed
          ? _value.mustBeConversationItem
          : mustBeConversationItem // ignore: cast_nullable_to_non_nullable
              as bool,
      onlyFromInstance: onlyFromInstance == freezed
          ? _value.onlyFromInstance
          : onlyFromInstance // ignore: cast_nullable_to_non_nullable
              as String?,
      replyVisibilityFilterCondition: replyVisibilityFilterCondition == freezed
          ? _value.replyVisibilityFilterCondition
          : replyVisibilityFilterCondition // ignore: cast_nullable_to_non_nullable
              as UnifediApiReplyVisibilityFilterCondition?,
      onlyPendingStatePublishedOrNull: onlyPendingStatePublishedOrNull ==
              freezed
          ? _value.onlyPendingStatePublishedOrNull
          : onlyPendingStatePublishedOrNull // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_StatusRepositoryFilters extends _StatusRepositoryFilters {
  const _$_StatusRepositoryFilters(
      {required this.onlyInListWithRemoteId,
      required this.onlyWithHashtag,
      required this.onlyFromAccountsFollowingByAccount,
      required this.onlyFromAccount,
      required this.onlyInConversation,
      required this.onlyLocalCondition,
      required this.onlyWithMedia,
      required this.withMuted,
      required this.excludeVisibilities,
      required this.onlyNoNsfwSensitive,
      required this.onlyNoReplies,
      required this.isFromHomeTimeline,
      required this.onlyFavourited,
      required this.onlyBookmarked,
      required this.excludeTextConditions,
      this.onlyNotDeleted = true,
      this.onlyNotHiddenLocallyOnDevice = true,
      required this.onlyRemoteCondition,
      this.mustBeConversationItem = false,
      required this.onlyFromInstance,
      required this.replyVisibilityFilterCondition,
      this.onlyPendingStatePublishedOrNull = true})
      : super._();

  @override
  final String? onlyInListWithRemoteId;
  @override
  final String? onlyWithHashtag;
  @override
  final IAccount? onlyFromAccountsFollowingByAccount;
  @override
  final IAccount? onlyFromAccount;
  @override
  final IConversationChat? onlyInConversation;
  @override
  final StatusOnlyLocalCondition? onlyLocalCondition;
  @override
  final bool? onlyWithMedia;
  @override
  final bool? withMuted;
  @override
  final List<UnifediApiVisibility>? excludeVisibilities;
  @override
  final bool? onlyNoNsfwSensitive;
  @override
  final bool? onlyNoReplies;
  @override
  final bool? isFromHomeTimeline;
  @override
  final bool? onlyFavourited;
  @override
  final bool? onlyBookmarked;
  @override
  final List<StatusTextCondition>? excludeTextConditions;
  @JsonKey(defaultValue: true)
  @override
  final bool onlyNotDeleted;
  @JsonKey(defaultValue: true)
  @override
  final bool onlyNotHiddenLocallyOnDevice;
  @override
  final StatusOnlyRemoteCondition? onlyRemoteCondition;
  @JsonKey(defaultValue: false)
  @override
  final bool mustBeConversationItem;
  @override
  final String? onlyFromInstance;
  @override
  final UnifediApiReplyVisibilityFilterCondition?
      replyVisibilityFilterCondition;
  @JsonKey(defaultValue: true)
  @override
  final bool onlyPendingStatePublishedOrNull;

  @override
  String toString() {
    return 'StatusRepositoryFilters(onlyInListWithRemoteId: $onlyInListWithRemoteId, onlyWithHashtag: $onlyWithHashtag, onlyFromAccountsFollowingByAccount: $onlyFromAccountsFollowingByAccount, onlyFromAccount: $onlyFromAccount, onlyInConversation: $onlyInConversation, onlyLocalCondition: $onlyLocalCondition, onlyWithMedia: $onlyWithMedia, withMuted: $withMuted, excludeVisibilities: $excludeVisibilities, onlyNoNsfwSensitive: $onlyNoNsfwSensitive, onlyNoReplies: $onlyNoReplies, isFromHomeTimeline: $isFromHomeTimeline, onlyFavourited: $onlyFavourited, onlyBookmarked: $onlyBookmarked, excludeTextConditions: $excludeTextConditions, onlyNotDeleted: $onlyNotDeleted, onlyNotHiddenLocallyOnDevice: $onlyNotHiddenLocallyOnDevice, onlyRemoteCondition: $onlyRemoteCondition, mustBeConversationItem: $mustBeConversationItem, onlyFromInstance: $onlyFromInstance, replyVisibilityFilterCondition: $replyVisibilityFilterCondition, onlyPendingStatePublishedOrNull: $onlyPendingStatePublishedOrNull)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _StatusRepositoryFilters &&
            (identical(other.onlyInListWithRemoteId, onlyInListWithRemoteId) ||
                const DeepCollectionEquality().equals(
                    other.onlyInListWithRemoteId, onlyInListWithRemoteId)) &&
            (identical(other.onlyWithHashtag, onlyWithHashtag) ||
                const DeepCollectionEquality()
                    .equals(other.onlyWithHashtag, onlyWithHashtag)) &&
            (identical(other.onlyFromAccountsFollowingByAccount, onlyFromAccountsFollowingByAccount) ||
                const DeepCollectionEquality().equals(
                    other.onlyFromAccountsFollowingByAccount,
                    onlyFromAccountsFollowingByAccount)) &&
            (identical(other.onlyFromAccount, onlyFromAccount) ||
                const DeepCollectionEquality()
                    .equals(other.onlyFromAccount, onlyFromAccount)) &&
            (identical(other.onlyInConversation, onlyInConversation) ||
                const DeepCollectionEquality()
                    .equals(other.onlyInConversation, onlyInConversation)) &&
            (identical(other.onlyLocalCondition, onlyLocalCondition) ||
                const DeepCollectionEquality()
                    .equals(other.onlyLocalCondition, onlyLocalCondition)) &&
            (identical(other.onlyWithMedia, onlyWithMedia) ||
                const DeepCollectionEquality()
                    .equals(other.onlyWithMedia, onlyWithMedia)) &&
            (identical(other.withMuted, withMuted) ||
                const DeepCollectionEquality()
                    .equals(other.withMuted, withMuted)) &&
            (identical(other.excludeVisibilities, excludeVisibilities) ||
                const DeepCollectionEquality()
                    .equals(other.excludeVisibilities, excludeVisibilities)) &&
            (identical(other.onlyNoNsfwSensitive, onlyNoNsfwSensitive) ||
                const DeepCollectionEquality()
                    .equals(other.onlyNoNsfwSensitive, onlyNoNsfwSensitive)) &&
            (identical(other.onlyNoReplies, onlyNoReplies) ||
                const DeepCollectionEquality()
                    .equals(other.onlyNoReplies, onlyNoReplies)) &&
            (identical(other.isFromHomeTimeline, isFromHomeTimeline) ||
                const DeepCollectionEquality()
                    .equals(other.isFromHomeTimeline, isFromHomeTimeline)) &&
            (identical(other.onlyFavourited, onlyFavourited) ||
                const DeepCollectionEquality()
                    .equals(other.onlyFavourited, onlyFavourited)) &&
            (identical(other.onlyBookmarked, onlyBookmarked) ||
                const DeepCollectionEquality()
                    .equals(other.onlyBookmarked, onlyBookmarked)) &&
            (identical(other.excludeTextConditions, excludeTextConditions) ||
                const DeepCollectionEquality().equals(
                    other.excludeTextConditions, excludeTextConditions)) &&
            (identical(other.onlyNotDeleted, onlyNotDeleted) ||
                const DeepCollectionEquality()
                    .equals(other.onlyNotDeleted, onlyNotDeleted)) &&
            (identical(other.onlyNotHiddenLocallyOnDevice, onlyNotHiddenLocallyOnDevice) ||
                const DeepCollectionEquality().equals(other.onlyNotHiddenLocallyOnDevice, onlyNotHiddenLocallyOnDevice)) &&
            (identical(other.onlyRemoteCondition, onlyRemoteCondition) || const DeepCollectionEquality().equals(other.onlyRemoteCondition, onlyRemoteCondition)) &&
            (identical(other.mustBeConversationItem, mustBeConversationItem) || const DeepCollectionEquality().equals(other.mustBeConversationItem, mustBeConversationItem)) &&
            (identical(other.onlyFromInstance, onlyFromInstance) || const DeepCollectionEquality().equals(other.onlyFromInstance, onlyFromInstance)) &&
            (identical(other.replyVisibilityFilterCondition, replyVisibilityFilterCondition) || const DeepCollectionEquality().equals(other.replyVisibilityFilterCondition, replyVisibilityFilterCondition)) &&
            (identical(other.onlyPendingStatePublishedOrNull, onlyPendingStatePublishedOrNull) || const DeepCollectionEquality().equals(other.onlyPendingStatePublishedOrNull, onlyPendingStatePublishedOrNull)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(onlyInListWithRemoteId) ^
      const DeepCollectionEquality().hash(onlyWithHashtag) ^
      const DeepCollectionEquality().hash(onlyFromAccountsFollowingByAccount) ^
      const DeepCollectionEquality().hash(onlyFromAccount) ^
      const DeepCollectionEquality().hash(onlyInConversation) ^
      const DeepCollectionEquality().hash(onlyLocalCondition) ^
      const DeepCollectionEquality().hash(onlyWithMedia) ^
      const DeepCollectionEquality().hash(withMuted) ^
      const DeepCollectionEquality().hash(excludeVisibilities) ^
      const DeepCollectionEquality().hash(onlyNoNsfwSensitive) ^
      const DeepCollectionEquality().hash(onlyNoReplies) ^
      const DeepCollectionEquality().hash(isFromHomeTimeline) ^
      const DeepCollectionEquality().hash(onlyFavourited) ^
      const DeepCollectionEquality().hash(onlyBookmarked) ^
      const DeepCollectionEquality().hash(excludeTextConditions) ^
      const DeepCollectionEquality().hash(onlyNotDeleted) ^
      const DeepCollectionEquality().hash(onlyNotHiddenLocallyOnDevice) ^
      const DeepCollectionEquality().hash(onlyRemoteCondition) ^
      const DeepCollectionEquality().hash(mustBeConversationItem) ^
      const DeepCollectionEquality().hash(onlyFromInstance) ^
      const DeepCollectionEquality().hash(replyVisibilityFilterCondition) ^
      const DeepCollectionEquality().hash(onlyPendingStatePublishedOrNull);

  @JsonKey(ignore: true)
  @override
  _$StatusRepositoryFiltersCopyWith<_StatusRepositoryFilters> get copyWith =>
      __$StatusRepositoryFiltersCopyWithImpl<_StatusRepositoryFilters>(
          this, _$identity);
}

abstract class _StatusRepositoryFilters extends StatusRepositoryFilters {
  const factory _StatusRepositoryFilters(
      {required String? onlyInListWithRemoteId,
      required String? onlyWithHashtag,
      required IAccount? onlyFromAccountsFollowingByAccount,
      required IAccount? onlyFromAccount,
      required IConversationChat? onlyInConversation,
      required StatusOnlyLocalCondition? onlyLocalCondition,
      required bool? onlyWithMedia,
      required bool? withMuted,
      required List<UnifediApiVisibility>? excludeVisibilities,
      required bool? onlyNoNsfwSensitive,
      required bool? onlyNoReplies,
      required bool? isFromHomeTimeline,
      required bool? onlyFavourited,
      required bool? onlyBookmarked,
      required List<StatusTextCondition>? excludeTextConditions,
      bool onlyNotDeleted,
      bool onlyNotHiddenLocallyOnDevice,
      required StatusOnlyRemoteCondition? onlyRemoteCondition,
      bool mustBeConversationItem,
      required String? onlyFromInstance,
      required UnifediApiReplyVisibilityFilterCondition?
          replyVisibilityFilterCondition,
      bool onlyPendingStatePublishedOrNull}) = _$_StatusRepositoryFilters;
  const _StatusRepositoryFilters._() : super._();

  @override
  String? get onlyInListWithRemoteId => throw _privateConstructorUsedError;
  @override
  String? get onlyWithHashtag => throw _privateConstructorUsedError;
  @override
  IAccount? get onlyFromAccountsFollowingByAccount =>
      throw _privateConstructorUsedError;
  @override
  IAccount? get onlyFromAccount => throw _privateConstructorUsedError;
  @override
  IConversationChat? get onlyInConversation =>
      throw _privateConstructorUsedError;
  @override
  StatusOnlyLocalCondition? get onlyLocalCondition =>
      throw _privateConstructorUsedError;
  @override
  bool? get onlyWithMedia => throw _privateConstructorUsedError;
  @override
  bool? get withMuted => throw _privateConstructorUsedError;
  @override
  List<UnifediApiVisibility>? get excludeVisibilities =>
      throw _privateConstructorUsedError;
  @override
  bool? get onlyNoNsfwSensitive => throw _privateConstructorUsedError;
  @override
  bool? get onlyNoReplies => throw _privateConstructorUsedError;
  @override
  bool? get isFromHomeTimeline => throw _privateConstructorUsedError;
  @override
  bool? get onlyFavourited => throw _privateConstructorUsedError;
  @override
  bool? get onlyBookmarked => throw _privateConstructorUsedError;
  @override
  List<StatusTextCondition>? get excludeTextConditions =>
      throw _privateConstructorUsedError;
  @override
  bool get onlyNotDeleted => throw _privateConstructorUsedError;
  @override
  bool get onlyNotHiddenLocallyOnDevice => throw _privateConstructorUsedError;
  @override
  StatusOnlyRemoteCondition? get onlyRemoteCondition =>
      throw _privateConstructorUsedError;
  @override
  bool get mustBeConversationItem => throw _privateConstructorUsedError;
  @override
  String? get onlyFromInstance => throw _privateConstructorUsedError;
  @override
  UnifediApiReplyVisibilityFilterCondition?
      get replyVisibilityFilterCondition => throw _privateConstructorUsedError;
  @override
  bool get onlyPendingStatePublishedOrNull =>
      throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$StatusRepositoryFiltersCopyWith<_StatusRepositoryFilters> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$StatusRepositoryOrderingTermDataTearOff {
  const _$StatusRepositoryOrderingTermDataTearOff();

  _StatusRepositoryOrderingTermData call(
      {required StatusRepositoryOrderType orderByType,
      required moor.OrderingMode orderingMode}) {
    return _StatusRepositoryOrderingTermData(
      orderByType: orderByType,
      orderingMode: orderingMode,
    );
  }
}

/// @nodoc
const $StatusRepositoryOrderingTermData =
    _$StatusRepositoryOrderingTermDataTearOff();

/// @nodoc
mixin _$StatusRepositoryOrderingTermData {
  StatusRepositoryOrderType get orderByType =>
      throw _privateConstructorUsedError;
  moor.OrderingMode get orderingMode => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StatusRepositoryOrderingTermDataCopyWith<StatusRepositoryOrderingTermData>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StatusRepositoryOrderingTermDataCopyWith<$Res> {
  factory $StatusRepositoryOrderingTermDataCopyWith(
          StatusRepositoryOrderingTermData value,
          $Res Function(StatusRepositoryOrderingTermData) then) =
      _$StatusRepositoryOrderingTermDataCopyWithImpl<$Res>;
  $Res call(
      {StatusRepositoryOrderType orderByType, moor.OrderingMode orderingMode});
}

/// @nodoc
class _$StatusRepositoryOrderingTermDataCopyWithImpl<$Res>
    implements $StatusRepositoryOrderingTermDataCopyWith<$Res> {
  _$StatusRepositoryOrderingTermDataCopyWithImpl(this._value, this._then);

  final StatusRepositoryOrderingTermData _value;
  // ignore: unused_field
  final $Res Function(StatusRepositoryOrderingTermData) _then;

  @override
  $Res call({
    Object? orderByType = freezed,
    Object? orderingMode = freezed,
  }) {
    return _then(_value.copyWith(
      orderByType: orderByType == freezed
          ? _value.orderByType
          : orderByType // ignore: cast_nullable_to_non_nullable
              as StatusRepositoryOrderType,
      orderingMode: orderingMode == freezed
          ? _value.orderingMode
          : orderingMode // ignore: cast_nullable_to_non_nullable
              as moor.OrderingMode,
    ));
  }
}

/// @nodoc
abstract class _$StatusRepositoryOrderingTermDataCopyWith<$Res>
    implements $StatusRepositoryOrderingTermDataCopyWith<$Res> {
  factory _$StatusRepositoryOrderingTermDataCopyWith(
          _StatusRepositoryOrderingTermData value,
          $Res Function(_StatusRepositoryOrderingTermData) then) =
      __$StatusRepositoryOrderingTermDataCopyWithImpl<$Res>;
  @override
  $Res call(
      {StatusRepositoryOrderType orderByType, moor.OrderingMode orderingMode});
}

/// @nodoc
class __$StatusRepositoryOrderingTermDataCopyWithImpl<$Res>
    extends _$StatusRepositoryOrderingTermDataCopyWithImpl<$Res>
    implements _$StatusRepositoryOrderingTermDataCopyWith<$Res> {
  __$StatusRepositoryOrderingTermDataCopyWithImpl(
      _StatusRepositoryOrderingTermData _value,
      $Res Function(_StatusRepositoryOrderingTermData) _then)
      : super(_value, (v) => _then(v as _StatusRepositoryOrderingTermData));

  @override
  _StatusRepositoryOrderingTermData get _value =>
      super._value as _StatusRepositoryOrderingTermData;

  @override
  $Res call({
    Object? orderByType = freezed,
    Object? orderingMode = freezed,
  }) {
    return _then(_StatusRepositoryOrderingTermData(
      orderByType: orderByType == freezed
          ? _value.orderByType
          : orderByType // ignore: cast_nullable_to_non_nullable
              as StatusRepositoryOrderType,
      orderingMode: orderingMode == freezed
          ? _value.orderingMode
          : orderingMode // ignore: cast_nullable_to_non_nullable
              as moor.OrderingMode,
    ));
  }
}

/// @nodoc

class _$_StatusRepositoryOrderingTermData
    implements _StatusRepositoryOrderingTermData {
  const _$_StatusRepositoryOrderingTermData(
      {required this.orderByType, required this.orderingMode});

  @override
  final StatusRepositoryOrderType orderByType;
  @override
  final moor.OrderingMode orderingMode;

  @override
  String toString() {
    return 'StatusRepositoryOrderingTermData(orderByType: $orderByType, orderingMode: $orderingMode)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _StatusRepositoryOrderingTermData &&
            (identical(other.orderByType, orderByType) ||
                const DeepCollectionEquality()
                    .equals(other.orderByType, orderByType)) &&
            (identical(other.orderingMode, orderingMode) ||
                const DeepCollectionEquality()
                    .equals(other.orderingMode, orderingMode)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(orderByType) ^
      const DeepCollectionEquality().hash(orderingMode);

  @JsonKey(ignore: true)
  @override
  _$StatusRepositoryOrderingTermDataCopyWith<_StatusRepositoryOrderingTermData>
      get copyWith => __$StatusRepositoryOrderingTermDataCopyWithImpl<
          _StatusRepositoryOrderingTermData>(this, _$identity);
}

abstract class _StatusRepositoryOrderingTermData
    implements StatusRepositoryOrderingTermData {
  const factory _StatusRepositoryOrderingTermData(
          {required StatusRepositoryOrderType orderByType,
          required moor.OrderingMode orderingMode}) =
      _$_StatusRepositoryOrderingTermData;

  @override
  StatusRepositoryOrderType get orderByType =>
      throw _privateConstructorUsedError;
  @override
  moor.OrderingMode get orderingMode => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$StatusRepositoryOrderingTermDataCopyWith<_StatusRepositoryOrderingTermData>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$StatusOnlyLocalConditionTearOff {
  const _$StatusOnlyLocalConditionTearOff();

  _StatusOnlyLocalCondition call({required String? localUrlHost}) {
    return _StatusOnlyLocalCondition(
      localUrlHost: localUrlHost,
    );
  }
}

/// @nodoc
const $StatusOnlyLocalCondition = _$StatusOnlyLocalConditionTearOff();

/// @nodoc
mixin _$StatusOnlyLocalCondition {
  String? get localUrlHost => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StatusOnlyLocalConditionCopyWith<StatusOnlyLocalCondition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StatusOnlyLocalConditionCopyWith<$Res> {
  factory $StatusOnlyLocalConditionCopyWith(StatusOnlyLocalCondition value,
          $Res Function(StatusOnlyLocalCondition) then) =
      _$StatusOnlyLocalConditionCopyWithImpl<$Res>;
  $Res call({String? localUrlHost});
}

/// @nodoc
class _$StatusOnlyLocalConditionCopyWithImpl<$Res>
    implements $StatusOnlyLocalConditionCopyWith<$Res> {
  _$StatusOnlyLocalConditionCopyWithImpl(this._value, this._then);

  final StatusOnlyLocalCondition _value;
  // ignore: unused_field
  final $Res Function(StatusOnlyLocalCondition) _then;

  @override
  $Res call({
    Object? localUrlHost = freezed,
  }) {
    return _then(_value.copyWith(
      localUrlHost: localUrlHost == freezed
          ? _value.localUrlHost
          : localUrlHost // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$StatusOnlyLocalConditionCopyWith<$Res>
    implements $StatusOnlyLocalConditionCopyWith<$Res> {
  factory _$StatusOnlyLocalConditionCopyWith(_StatusOnlyLocalCondition value,
          $Res Function(_StatusOnlyLocalCondition) then) =
      __$StatusOnlyLocalConditionCopyWithImpl<$Res>;
  @override
  $Res call({String? localUrlHost});
}

/// @nodoc
class __$StatusOnlyLocalConditionCopyWithImpl<$Res>
    extends _$StatusOnlyLocalConditionCopyWithImpl<$Res>
    implements _$StatusOnlyLocalConditionCopyWith<$Res> {
  __$StatusOnlyLocalConditionCopyWithImpl(_StatusOnlyLocalCondition _value,
      $Res Function(_StatusOnlyLocalCondition) _then)
      : super(_value, (v) => _then(v as _StatusOnlyLocalCondition));

  @override
  _StatusOnlyLocalCondition get _value =>
      super._value as _StatusOnlyLocalCondition;

  @override
  $Res call({
    Object? localUrlHost = freezed,
  }) {
    return _then(_StatusOnlyLocalCondition(
      localUrlHost: localUrlHost == freezed
          ? _value.localUrlHost
          : localUrlHost // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_StatusOnlyLocalCondition implements _StatusOnlyLocalCondition {
  const _$_StatusOnlyLocalCondition({required this.localUrlHost});

  @override
  final String? localUrlHost;

  @override
  String toString() {
    return 'StatusOnlyLocalCondition(localUrlHost: $localUrlHost)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _StatusOnlyLocalCondition &&
            (identical(other.localUrlHost, localUrlHost) ||
                const DeepCollectionEquality()
                    .equals(other.localUrlHost, localUrlHost)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(localUrlHost);

  @JsonKey(ignore: true)
  @override
  _$StatusOnlyLocalConditionCopyWith<_StatusOnlyLocalCondition> get copyWith =>
      __$StatusOnlyLocalConditionCopyWithImpl<_StatusOnlyLocalCondition>(
          this, _$identity);
}

abstract class _StatusOnlyLocalCondition implements StatusOnlyLocalCondition {
  const factory _StatusOnlyLocalCondition({required String? localUrlHost}) =
      _$_StatusOnlyLocalCondition;

  @override
  String? get localUrlHost => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$StatusOnlyLocalConditionCopyWith<_StatusOnlyLocalCondition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$StatusOnlyRemoteConditionTearOff {
  const _$StatusOnlyRemoteConditionTearOff();

  _StatusOnlyRemoteCondition call({required String? localUrlHost}) {
    return _StatusOnlyRemoteCondition(
      localUrlHost: localUrlHost,
    );
  }
}

/// @nodoc
const $StatusOnlyRemoteCondition = _$StatusOnlyRemoteConditionTearOff();

/// @nodoc
mixin _$StatusOnlyRemoteCondition {
  String? get localUrlHost => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StatusOnlyRemoteConditionCopyWith<StatusOnlyRemoteCondition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StatusOnlyRemoteConditionCopyWith<$Res> {
  factory $StatusOnlyRemoteConditionCopyWith(StatusOnlyRemoteCondition value,
          $Res Function(StatusOnlyRemoteCondition) then) =
      _$StatusOnlyRemoteConditionCopyWithImpl<$Res>;
  $Res call({String? localUrlHost});
}

/// @nodoc
class _$StatusOnlyRemoteConditionCopyWithImpl<$Res>
    implements $StatusOnlyRemoteConditionCopyWith<$Res> {
  _$StatusOnlyRemoteConditionCopyWithImpl(this._value, this._then);

  final StatusOnlyRemoteCondition _value;
  // ignore: unused_field
  final $Res Function(StatusOnlyRemoteCondition) _then;

  @override
  $Res call({
    Object? localUrlHost = freezed,
  }) {
    return _then(_value.copyWith(
      localUrlHost: localUrlHost == freezed
          ? _value.localUrlHost
          : localUrlHost // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc
abstract class _$StatusOnlyRemoteConditionCopyWith<$Res>
    implements $StatusOnlyRemoteConditionCopyWith<$Res> {
  factory _$StatusOnlyRemoteConditionCopyWith(_StatusOnlyRemoteCondition value,
          $Res Function(_StatusOnlyRemoteCondition) then) =
      __$StatusOnlyRemoteConditionCopyWithImpl<$Res>;
  @override
  $Res call({String? localUrlHost});
}

/// @nodoc
class __$StatusOnlyRemoteConditionCopyWithImpl<$Res>
    extends _$StatusOnlyRemoteConditionCopyWithImpl<$Res>
    implements _$StatusOnlyRemoteConditionCopyWith<$Res> {
  __$StatusOnlyRemoteConditionCopyWithImpl(_StatusOnlyRemoteCondition _value,
      $Res Function(_StatusOnlyRemoteCondition) _then)
      : super(_value, (v) => _then(v as _StatusOnlyRemoteCondition));

  @override
  _StatusOnlyRemoteCondition get _value =>
      super._value as _StatusOnlyRemoteCondition;

  @override
  $Res call({
    Object? localUrlHost = freezed,
  }) {
    return _then(_StatusOnlyRemoteCondition(
      localUrlHost: localUrlHost == freezed
          ? _value.localUrlHost
          : localUrlHost // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$_StatusOnlyRemoteCondition implements _StatusOnlyRemoteCondition {
  const _$_StatusOnlyRemoteCondition({required this.localUrlHost});

  @override
  final String? localUrlHost;

  @override
  String toString() {
    return 'StatusOnlyRemoteCondition(localUrlHost: $localUrlHost)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _StatusOnlyRemoteCondition &&
            (identical(other.localUrlHost, localUrlHost) ||
                const DeepCollectionEquality()
                    .equals(other.localUrlHost, localUrlHost)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(localUrlHost);

  @JsonKey(ignore: true)
  @override
  _$StatusOnlyRemoteConditionCopyWith<_StatusOnlyRemoteCondition>
      get copyWith =>
          __$StatusOnlyRemoteConditionCopyWithImpl<_StatusOnlyRemoteCondition>(
              this, _$identity);
}

abstract class _StatusOnlyRemoteCondition implements StatusOnlyRemoteCondition {
  const factory _StatusOnlyRemoteCondition({required String? localUrlHost}) =
      _$_StatusOnlyRemoteCondition;

  @override
  String? get localUrlHost => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$StatusOnlyRemoteConditionCopyWith<_StatusOnlyRemoteCondition>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
class _$StatusTextConditionTearOff {
  const _$StatusTextConditionTearOff();

  _StatusTextCondition call({required String phrase, required bool wholeWord}) {
    return _StatusTextCondition(
      phrase: phrase,
      wholeWord: wholeWord,
    );
  }
}

/// @nodoc
const $StatusTextCondition = _$StatusTextConditionTearOff();

/// @nodoc
mixin _$StatusTextCondition {
  String get phrase => throw _privateConstructorUsedError;
  bool get wholeWord => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $StatusTextConditionCopyWith<StatusTextCondition> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StatusTextConditionCopyWith<$Res> {
  factory $StatusTextConditionCopyWith(
          StatusTextCondition value, $Res Function(StatusTextCondition) then) =
      _$StatusTextConditionCopyWithImpl<$Res>;
  $Res call({String phrase, bool wholeWord});
}

/// @nodoc
class _$StatusTextConditionCopyWithImpl<$Res>
    implements $StatusTextConditionCopyWith<$Res> {
  _$StatusTextConditionCopyWithImpl(this._value, this._then);

  final StatusTextCondition _value;
  // ignore: unused_field
  final $Res Function(StatusTextCondition) _then;

  @override
  $Res call({
    Object? phrase = freezed,
    Object? wholeWord = freezed,
  }) {
    return _then(_value.copyWith(
      phrase: phrase == freezed
          ? _value.phrase
          : phrase // ignore: cast_nullable_to_non_nullable
              as String,
      wholeWord: wholeWord == freezed
          ? _value.wholeWord
          : wholeWord // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc
abstract class _$StatusTextConditionCopyWith<$Res>
    implements $StatusTextConditionCopyWith<$Res> {
  factory _$StatusTextConditionCopyWith(_StatusTextCondition value,
          $Res Function(_StatusTextCondition) then) =
      __$StatusTextConditionCopyWithImpl<$Res>;
  @override
  $Res call({String phrase, bool wholeWord});
}

/// @nodoc
class __$StatusTextConditionCopyWithImpl<$Res>
    extends _$StatusTextConditionCopyWithImpl<$Res>
    implements _$StatusTextConditionCopyWith<$Res> {
  __$StatusTextConditionCopyWithImpl(
      _StatusTextCondition _value, $Res Function(_StatusTextCondition) _then)
      : super(_value, (v) => _then(v as _StatusTextCondition));

  @override
  _StatusTextCondition get _value => super._value as _StatusTextCondition;

  @override
  $Res call({
    Object? phrase = freezed,
    Object? wholeWord = freezed,
  }) {
    return _then(_StatusTextCondition(
      phrase: phrase == freezed
          ? _value.phrase
          : phrase // ignore: cast_nullable_to_non_nullable
              as String,
      wholeWord: wholeWord == freezed
          ? _value.wholeWord
          : wholeWord // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$_StatusTextCondition implements _StatusTextCondition {
  const _$_StatusTextCondition({required this.phrase, required this.wholeWord});

  @override
  final String phrase;
  @override
  final bool wholeWord;

  @override
  String toString() {
    return 'StatusTextCondition(phrase: $phrase, wholeWord: $wholeWord)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _StatusTextCondition &&
            (identical(other.phrase, phrase) ||
                const DeepCollectionEquality().equals(other.phrase, phrase)) &&
            (identical(other.wholeWord, wholeWord) ||
                const DeepCollectionEquality()
                    .equals(other.wholeWord, wholeWord)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(phrase) ^
      const DeepCollectionEquality().hash(wholeWord);

  @JsonKey(ignore: true)
  @override
  _$StatusTextConditionCopyWith<_StatusTextCondition> get copyWith =>
      __$StatusTextConditionCopyWithImpl<_StatusTextCondition>(
          this, _$identity);
}

abstract class _StatusTextCondition implements StatusTextCondition {
  const factory _StatusTextCondition(
      {required String phrase,
      required bool wholeWord}) = _$_StatusTextCondition;

  @override
  String get phrase => throw _privateConstructorUsedError;
  @override
  bool get wholeWord => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$StatusTextConditionCopyWith<_StatusTextCondition> get copyWith =>
      throw _privateConstructorUsedError;
}
